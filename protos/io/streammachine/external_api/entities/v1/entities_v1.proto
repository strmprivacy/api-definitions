syntax = "proto3";
package io.streammachine.external_api.entities.v1;
// TODO discuss
option java_multiple_files = true;

import "google/protobuf/timestamp.proto";

// See our attribute spreadsheet for the initial fields version
// https://docs.google.com/spreadsheets/d/12dooxWXRQjEKhZxS_Bpa4fXpDpaEbPu9JorxOo_BElQ

/**
Stream entity.

Streams are source or derived streams depending on whether or not linked_stream is null.
Key streams are a separate entity in the api.
 */
message Stream {
  string billing_id                   = 1;
  string name                         = 2;
  string description                  = 3; // customer purpose.
  repeated int32 consent_levels       = 4; // consent levels for derived streams
  ConsentLevelType consent_level_type = 5; // how event consent-levels are interpreted by decrypters.
  bool enabled                        = 6; // whether or not this stream is enabled.
  float rate_limit                    = 7; // filled in from customer profile
  int64 event_ct_limit                = 8; // filled in from customer profile
  string linked_stream                = 9; // null for source streams
  repeated string tags                = 10; // customer purposes.
  string status                       = 11; // engineering status message. Add enum when we know more.
  repeated Credentials credentials    = 12;
}

/**
Consent level is meant to interpret the consent-levels of an event for decryption purposes only.

Cumulative means that the highest consent-level in an event must be greater than or equal to the single requested level
for the decrypted stream.

Granular means that the set of consent-levels in an event must enclose the set of requested event levels for the
decrypted stream.
 */
enum ConsentLevelType {
  CONSENT_LEVEL_TYPE_UNSPECIFIED = 0;
  CONSENT_LEVEL_TYPE_CUMULATIVE  = 1;
  CONSENT_LEVEL_TYPE_GRANULAR    = 2;
}

/**
A Stream of key-link, encryption-key messages created from a source stream
with the same `name`.
 */
message KeyStream {
  string billing_id    = 1;
  string name          = 2; // identical to the source stream
  string status        = 5;
}

/** refer to a stream or key stream.
 */
message StreamRef  {
  string stream_name = 1;
  bool key_stream = 2; // whether we refer to the source stream or its corresponding keys stream.
}

/**
Credentials to produce to the event-gateway, or to consume from egress.
 */
message Credentials {
  string billing_id    = 1;
  string client_id     = 2;
  StreamRef stream_ref = 3;
  string client_secret = 4;
}

/** the sink configuration used by the batch exporters.

 */
message Sink {
  string billing_id  = 1;
  string name        = 2;
  SinkType sink_type = 3;
  string bucket_name = 4;
  string credentials = 5;
}

enum SinkType {
  SINK_TYPE_UNSPECIFIED = 0;
  SINK_TYPE_S3          = 1;
  SINK_TYPE_GCLOUD      = 2;
  SINK_TYPE_AZURE       = 3;
  SINK_TYPE_MONGO       = 4;
  SINK_TYPE_ELASTIC     = 5;
}

/**
A batch exporter.
 */
message BatchExporter {
  string billing_id    = 1;
  string name          = 2;
  StreamRef stream_ref = 3;
  int32 interval       = 4 ; // interval in seconds
  string sink_name     = 5;
  string path_prefix   = 6;
}

/**
Currently only our internal shared export cluster.
 */
message KafkaCluster {
  KafkaClusterRef cluster_ref  = 1;
  string bootstrap_servers     = 2;
  AuthMechanism auth_mechanism = 3;
  string token_uri             = 4;
}

/**
How to refer to a certain Kafka cluster.
 */
message KafkaClusterRef {
  string billing_id = 1; // streammachine
  string name = 2; // shared export
}

enum AuthMechanism {
  // TODO align values with JAAS.
  AUTH_MECHANISM_UNSPECIFIED = 0;
  AUTH_MECHANISM_PLAINTEXT   = 1;
  AUTH_MECHANISM_SASL        = 2;
  AUTH_MECHANISM_TLS         = 3;
}

message KafkaExporter  {
  string billing_id           = 1;
  string name                 = 2; // typically default  <cluster-name>-<stream-name>
  StreamRef stream_ref        = 3; // what stream
  KafkaClusterRef cluster_ref = 4; // what cluster to produce to.
  string produce_to_topic     = 5; // the topic this exporter produces to
  string client_id            = 6; // how to produce to the cluster.
  string client_secret        = 7; // how to produce to the cluster.
}

/**
User credentials to consume from topic produced by Kafka Exporter.

The kafka exporter is linked to a certain cluster, so this entity is bound to a certain
kafka cluster.
 */
message KafkaUser {
  string billing_id          = 1;
  string name                = 2;
  string kafka_exporter_name = 3;
  string topic               = 4;
  string client_id           = 5;
  string client_secret       = 6;
}

/**
for descriptive purposes only.
 */
message ConsentLevel {
  string billing_id = 1;
  string name = 2; // some text like 'analytics'
  int32 value = 3; // the typically small integer value that we use in the events.
  string dpo_reference=4; // reference to DPO documentation.
}

/**
event usage information.
 */
message Events {
  string billing_id = 1;
  repeated EventsInfo event_infos = 3;
}

message EventsInfo {
  StreamRef stream_ref = 1;
  repeated EventsPeriodInfo info = 2;
}

message EventsPeriodInfo {
  google.protobuf.Timestamp t0 = 1;
  int32 duration_s = 2;
  int64 count = 3; // the number of events in this interval.
}

message Schema {
  string billing_id = 1;
  string handle = 2;
  string name = 3;
  string version = 4;
  SchemaType type = 5;
  string definition = 6;
  string status_message = 7;
  Status status = 8;
}

enum SchemaType {
  SCHEMA_TYPE_UNSPECIFIED = 0 ;
  SCHEMA_TYPE_AVRO=1;
  SCHEMA_TYPE_JSONSCHEMA=2;
}

message EventContract {
  string billing_id = 1;
  string handle = 2;
  string name = 3;
  string version = 4;
  string definition = 6;
  string status_message = 7;
  Status status = 8;
  string schema_handle = 9;
  string schema_name = 10;
  string schema_version = 11;
}

enum Status {
  STATUS_UNSPECIFIED = 0;
  STATUS_PENDING = 1;
  STATUS_IN_REVIEW = 2;
  STATUS_REJECTED = 3;
  STATUS_ACTIVE = 4;
  STATUS_DELETED = 5;
}

message CustomerProfile {
  string billing_id = 1;
  string limits = 2;
  string defaults = 3;
  string subscription_type = 4;
}

message StreamRelations {
  streammachine.external_api.entities.v1.Stream self = 1;
  streammachine.external_api.entities.v1.KeyStream key_stream = 2;
  repeated streammachine.external_api.entities.v1.Stream derived = 3;
  repeated streammachine.external_api.entities.v1.BatchExporter batch_exporters = 4;
  repeated streammachine.external_api.entities.v1.KafkaExporterRelations kafka_exporters = 5;
}

message KafkaExporterRelations {
  streammachine.external_api.entities.v1.KafkaExporter self = 1;
  repeated streammachine.external_api.entities.v1.KafkaUser users = 2;
}

message SinkRelations {
  streammachine.external_api.entities.v1.Sink self = 1;
  repeated streammachine.external_api.entities.v1.BatchExporter exporters = 2;
}
