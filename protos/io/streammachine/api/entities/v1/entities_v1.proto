syntax = "proto3";

package io.streammachine.api.entities.v1;

import "google/api/field_behavior.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option go_package = "streammachine.io/api/entities/v1;entities";
option java_multiple_files = true;

// (-- See our attribute spreadsheet for the initial fields version
//     https://docs.google.com/spreadsheets/d/12dooxWXRQjEKhZxS_Bpa4fXpDpaEbPu9JorxOo_BElQ --)

/*
  Streams are source or derived streams depending on whether or not linked_stream is null.
  Key streams are a separate entity in the api.
 */
message Stream {
  // (-- TODO: I think we should use StreamRef here instead of these 2 properties (billing_id + name) --)
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  // customer's description for this Stream.
  string description = 3;
  // consent levels for derived streams
  repeated int32 consent_levels = 4;
  // how event consent-levels are interpreted by decrypters.
  ConsentLevelType consent_level_type = 5;
  // whether or not this stream is enabled.
  bool enabled = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  // stream limits
  Limits limits = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
  // null for source streams
  string linked_stream = 8;
  // customer purposes.
  repeated string tags = 9;
  repeated Credentials credentials = 10 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message Limits {
  // filled in from customer profile
  int64 event_rate = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // filled in from customer profile
  int64 event_count = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/*
A Stream of key-link, encryption-key messages created from a source stream
with the same `name`.
 * -- TODO should key stream be a separate resource? --
 * -- TODO key stream (also on SOS database level) should be named export_keys, which is a property on a Stream (a source stream)?
 */
message KeyStream {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // identical to the source stream
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  // -- TODO: this field is not used --
  string status = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/* refers to a stream or key stream.
 */
message StreamRef {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // the name of the stream
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  // (-- TODO: Can't we do this in another way than with a boolean flag? --)
  // whether we refer to the source stream or its corresponding keys stream.
  bool key_stream = 3;
}

/*
Credentials to produce to the event-gateway, or to consume from egress.
 */
message Credentials {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string client_id = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  /* as this property is secret, it is not always returned */
  string client_secret = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/* the sink configuration used by the batch exporters. */
message Sink {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  SinkType sink_type = 3 [(google.api.field_behavior) = REQUIRED];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to a bucket name. --)
  string bucket_name = 4 [(google.api.field_behavior) = REQUIRED];
  // The credentials that are to be used to access the sink target (e.g. S3 or Google Cloud Storage)
  string bucket_credentials = 5 [(google.api.field_behavior) = REQUIRED];
}

/*
A batch exporter.
 */
message BatchExporter {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  StreamRef stream_ref = 3 [(google.api.field_behavior) = REQUIRED];
  // granularity of seconds, nanos is unused
  google.protobuf.Duration interval = 4 [(google.api.field_behavior) = REQUIRED];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to the sink by name. --)
  string sink_name = 5 [(google.api.field_behavior) = REQUIRED];
  string path_prefix = 6;
}

/*
Currently only our internal shared export cluster.
 */
message KafkaCluster {
  KafkaClusterRef ref = 1 [(google.api.field_behavior) = REQUIRED];
  string bootstrap_servers = 2 [(google.api.field_behavior) = REQUIRED];
  AuthMechanism auth_mechanism = 3 [(google.api.field_behavior) = REQUIRED];
  string token_uri = 4;
  // (-- TODO define what this means --)
  bool owned = 5;
}

/*
How to refer to a certain Kafka cluster.
 */
message KafkaClusterRef {
  // (-- streammachine for the default export cluster --)
  string billing_id = 1 [(google.api.field_behavior) = REQUIRED];
  // (-- shared export --)
  string name = 2 [(google.api.field_behavior) = REQUIRED];
}

message KafkaExporter {
  // default value  <cluster-name>-<stream-name>
  string name = 1 [(google.api.field_behavior) = REQUIRED];
  StreamRef stream_ref = 2 [(google.api.field_behavior) = REQUIRED];
  KafkaExporterTarget target = 3 [(google.api.field_behavior) = REQUIRED];
  repeated KafkaUser users = 4;
}

message KafkaExporterTarget {
  // what cluster to produce to
  KafkaClusterRef cluster_ref = 1 [(google.api.field_behavior) = REQUIRED];
  // the topic this exporter produces to
  string topic = 2 [(google.api.field_behavior) = REQUIRED];
  // used to access the target Kafka Cluster in case of OAuth based authentication
  string client_id = 3;
  // used to access the target Kafka Cluster in case of OAuth based authentication
  string client_secret = 4;
}

/*
User credentials to consume from topic produced by Kafka Exporter.

The kafka exporter is linked to a certain cluster, so this entity is bound to a certain
kafka cluster.
 */
message KafkaUser {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string name = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to the kafka exporter by name. --)
  string kafka_exporter_name = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  string topic = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
  string client_id = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
  string client_secret = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- TODO should we even include this in our api at the moment? What is the probability of a customer wanting to cross produce to another customer's cluster? --)
  string cluster_billing_id = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to the cluster by name. --)
  string cluster_name = 8 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to the stream by name. --)
  string stream_name = 9 [(google.api.field_behavior) = REQUIRED];
}

/*
for descriptive purposes only.
 */
message ConsentLevelMapping {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // some text like 'analytics'
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  // the typically small integer value that we use in the events.
  int32 level = 3 [(google.api.field_behavior) = REQUIRED];
}

message WindowedEventCount {
  google.protobuf.Timestamp start_time = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp end_time = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  int64 event_count = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message SchemaRef {
  string handle = 1 [(google.api.field_behavior) = REQUIRED];
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  string version = 3 [(google.api.field_behavior) = REQUIRED];
  SchemaType schema_type = 4 [(google.api.field_behavior) = REQUIRED];
}

message Schema {
  SchemaRef ref = 1 [(google.api.field_behavior) = REQUIRED];
  State state = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- 'is' is intentional here (see https://google.aip.dev/140#booleans) --)
  bool is_public = 3;
  string definition = 4 [(google.api.field_behavior) = REQUIRED];
}

message EventContractRef {
  string handle = 1 [(google.api.field_behavior) = REQUIRED];
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  string version = 3 [(google.api.field_behavior) = REQUIRED];
}

message EventContract {
  EventContractRef ref = 1 [(google.api.field_behavior) = REQUIRED];
  State state = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  SchemaRef schema_ref = 3[(google.api.field_behavior) = REQUIRED];
  // (-- 'is' is intentional here (see https://google.aip.dev/140#booleans) --)
  bool is_public = 4;
  string key_field = 5[(google.api.field_behavior) = REQUIRED];
  map<string, int32> pii_fields = 6;
  repeated Validation validations = 7;
}

message Validation {
  string field = 1 [(google.api.field_behavior) = REQUIRED];
  string type = 2 [(google.api.field_behavior) = REQUIRED];
  string value = 3 [(google.api.field_behavior) = REQUIRED];
}

message StreamTree {
  Stream stream = 1 [(google.api.field_behavior) = REQUIRED];
  KeyStream key_stream = 2;
  repeated Stream derived = 3;
  repeated BatchExporter batch_exporters = 4;
  repeated KafkaExporter kafka_exporters = 5;
}

message SinkTree {
  Sink sink = 1 [(google.api.field_behavior) = REQUIRED];
  repeated BatchExporter batch_exporters = 2;
}

/*
Consent level is meant to interpret the consent-levels of an event for decryption purposes only.

Cumulative means that the highest consent-level in an event must be greater than or equal to the single requested level
for the decrypted stream.

Granular means that the set of consent-levels in an event must enclose the set of requested event levels for the
decrypted stream.
 */
enum ConsentLevelType {
  CONSENT_LEVEL_TYPE_UNSPECIFIED = 0;
  CUMULATIVE = 1;
  GRANULAR = 2;
}

enum SinkType {
  SINK_TYPE_UNSPECIFIED = 0;
  S3 = 1;
  GCLOUD = 2;
}

// (-- TODO align values with JAAS. see https://docs.confluent.io/platform/current/kafka/overview-authentication-methods.html --)
//     also see the Kafka exporter to determine the correct terminology here
//     SASL_SSL should probably be SASL_OAUTHBEARER --)
enum AuthMechanism {
  AUTH_MECHANISM_UNSPECIFIED = 0;
  SASL_PLAIN = 1;
  SASL_SSL = 2;
}

enum State {
  STATE_UNSPECIFIED = 0;
  PENDING = 1;
  IN_REVIEW = 2;
  REJECTED = 3;
  ACTIVE = 4;
  DELETED = 5;
}

enum SchemaType {
  SCHEMA_TYPE_UNSPECIFIED = 0 ;
  AVRO = 1;
  JSONSCHEMA = 2;
}
