syntax = "proto3";

package strmprivacy.api.entities.v1;

import "google/api/field_behavior.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/type/datetime.proto";
import "validate/validate.proto";

option go_package = "github.com/strmprivacy/api-definitions-go/v2/api/entities/v1;entities";
option java_package = "io.strmprivacy.api.entities.v1";
option java_multiple_files = true;


/*
  Streams are source or derived streams depending on whether or not linked_stream is null.
  Key streams are a separate entity in the api.
 */
message Stream {
  StreamRef ref = 1 [(google.api.field_behavior) = REQUIRED, (validate.rules).message.required = true];
  // Stream description
  string description = 2 [(validate.rules).string = {ignore_empty: true, max_len: 1000}];
  /*
  consent levels for derived streams

  constraints:
  if consent_level_type ==  CUMULATIVE then
    size = 1
  endif
   */
  repeated int32 consent_levels = 3 [(validate.rules).repeated.max_items = 50];
  // how event consent-levels are interpreted by decrypters.
  ConsentLevelType consent_level_type = 4;
  // whether or not this stream is enabled.
  bool enabled = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
  // stream limits
  Limits limits = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  // null for source streams
  string linked_stream = 7;
  // tags are meant for customers to tag their streams
  repeated string tags = 8 [(validate.rules).repeated = {
    max_items: 20
    unique: true
    items: {string: {max_len: 100}}
  }];
  repeated Credentials credentials = 9 [(google.api.field_behavior) = OUTPUT_ONLY];

  /* field masking is defined per OUTPUT stream and event-contract ref. combination

  The default empty map means no masking. Otherwise, the algorithm in the decrypter is as follows.

  * A source stream is (partially) decrypted, and events that don't have enough permissions are dropped.
  * the event contract ref string is used to find a MaskedFields instance.
  * if present, for all field patterns in the MaskedFields instance, the hash with the specified seed is applied.
   */
  MaskedFields masked_fields = 10;
  // Kafka topic of the stream. Deprecated in favor of topic in message ExtendedStream
  string kafka_topic = 11 [deprecated = true, (google.api.field_behavior) = OUTPUT_ONLY];
  // The id of the policy that should be applied to this stream's data
  string policy_id = 12 [(validate.rules).string = {ignore_empty: true, uuid: true}];
}

message ExtendedStream {
  strmprivacy.api.entities.v1.Stream stream = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // The Kafka Topic name that the data is published to
  string topic = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // The UUID identifier of the Stream, used in Kubernetes
  string uuid = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  /* whether or not a key stream EXISTS for this stream.
   * So when this flag is true, there are TWO topics associated with this stream.
   * TODO: Rename to has_key_stream, requires many updates in api gateway. */
  bool key_stream = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message ExtendedStreamGroup {
  ExtendedStream source_stream = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  repeated ExtendedStream derived_streams = 2;
}

message MaskedFields {
  // Default Murmurhash3 if empty
  string hash_type = 1;
  // hashing seed
  string seed = 2 [
    (validate.rules).string = {
      // if empty skip validations and a default seed is generated upon creation
      ignore_empty: true,
      max_len: 1000,
      pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$"
    }
  ];
  /*
  map of event-contract-ref vs field patterns

  constraints:
    * data-contract-refs should be existing data contracts
    * field_patterns should be valid values (checked by events-core)
    * the field_patterns list should have no duplicates.
   */
  map<string, PatternList> field_patterns = 3;
  message PatternList {
    repeated string field_patterns = 1 [(validate.rules).repeated = {
      unique: true
      items: {
        string: {
          not_contains: "strmMeta" // cannot apply masking on strmMeta
        }
      }
    }];
  }
}

message Limits {
  // filled in from customer profile
  int64 event_rate = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // filled in from customer profile
  int64 event_count = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/*
A Stream of key-link, encryption-key, policy-id messages created from a source stream
with the same `name`.
 */
message KeyStream {
  KeyStreamRef ref = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // -- TODO: this field is not used --
  string status = 2 [deprecated = true, (google.api.field_behavior) = OUTPUT_ONLY];
  string kafka_topic = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/* refers to a event stream.
 */
message StreamRef {
  string billing_id = 1 [deprecated = true, (validate.rules).string = {len: 0, ignore_empty: true}];
  /*
  the name of the stream
  constraints: generic name
  */
  string name = 2 [(validate.rules).string = {
    // if empty skip validations and a default name is generated upon creation
    ignore_empty: true,
    min_len: 4,
    max_len: 100,
    pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$"
  }];
  string project_id = 3 [(validate.rules).string.uuid = true];
}

/* refers to a key stream.
 */
message KeyStreamRef {
  string billing_id = 1 [deprecated = true, (validate.rules).string = {len: 0, ignore_empty: true}];
  // the name of the stream
  string name = 2 [(validate.rules).string = {
    // if empty skip validations and a default name is generated upon creation
    ignore_empty: true,
    min_len: 4,
    max_len: 100,
    // Only printable unicode characters are supported
    pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$"
  }];
  string project_id = 3 [(validate.rules).string.uuid = true];
}

/*
Credentials to produce to the event-gateway, or to consume from egress.
 */
message Credentials {
  string billing_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string client_id = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  /* as this property is secret, it is not always returned */
  string client_secret = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  string project_id = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
}

/* the sink config used by the batch exporters. */
message Sink {
  option deprecated = true;
  SinkRef ref = 1 [(google.api.field_behavior) = REQUIRED];
  SinkType sink_type = 2 [(google.api.field_behavior) = REQUIRED];
  oneof config {
    BucketConfig bucket = 4;
  }
}

message SinkRef {
  option deprecated = true;
  string billing_id = 1 [(google.api.field_behavior) = REQUIRED];
  /* constraints: generic name */
  string name = 2 [(google.api.field_behavior) = REQUIRED];
}

message BucketConfig {
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to a bucket name. --)
  /* constraints: validated via access check */
  string bucket_name = 4 [(google.api.field_behavior) = REQUIRED];
  // The credentials that are to be used to access the sink target (e.g. S3 or Google Cloud Storage)
  string credentials = 5 [(google.api.field_behavior) = REQUIRED];
  /* The ARN of the role to assume.
     If present, start an AssumeRole flow to get temporary credentials in another AWS account.
     This is used when the customer has a separate users account.
     Default there is no assumed role. */
  string assume_role_arn = 6;
}

message DataConnector {
  DataConnectorRef ref = 1 [(validate.rules).message.required = true];
  oneof location {
    option (validate.required) = true;
    AwsS3BucketLocation s3_bucket = 2;
    GoogleCloudStorageBucketLocation google_cloud_storage_bucket = 3;
    AzureBlobStorageContainerLocation azure_blob_storage_container = 4;
  }
  string uuid = 5 [(validate.rules).string = {uuid: true, ignore_empty: true}];
  DataConnectorDependentEntities dependent_entities = 6;
}

message DataConnectorRef {
  string billing_id = 1 [deprecated = true, (validate.rules).string = {len: 0, ignore_empty: true}];
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100}];
  string project_id = 3 [(validate.rules).string.uuid = true];
}

message DataConnectorDependentEntities {
  repeated BatchExporter batch_exporters = 1;
  repeated BatchJob batch_jobs = 2;
  repeated MicroAggregationBatchJob micro_aggregation_batch_jobs = 3;
}

message AwsS3BucketLocation {
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to a bucket name. --)
  string bucket_name = 1 [(validate.rules).string.min_len = 1];
  // The AWS IAM credentials that give access to this bucket, in JSON format as returned by the AWS CLI. This means a
  // JSON with at least one property: "AccessKey", which contains at least the two properties: "AccessKeyId" and
  // "SecretAccessKey".
  string credentials = 2 [(validate.rules).string.min_len = 1];
  /* The ARN of the role to assume.
     If present, start an AssumeRole flow to get temporary credentials in another AWS account.
     This is used when the customer has a separate users account.
     Default there is no assumed role. */
  string assume_role_arn = 3 [(validate.rules).string = {min_len: 1, ignore_empty: true}];
}

message GoogleCloudStorageBucketLocation {
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to a bucket name. --)
  string bucket_name = 1 [(validate.rules).string.min_len = 1];
  // The Google Cloud Service Account credentials JSON that is used to access the Google Cloud Storage bucket.
  // We do not support credentials in P12 format.
  string credentials = 2 [(validate.rules).string.min_len = 1];
}

message AzureBlobStorageContainerLocation {
  // The base URI of the Azure Storage Account. Typically this is 'https://<your-account-name>.blob.core.windows.net',
  // but Azure users can map this to their own domain or subdomain.
  string storage_account_uri = 1 [(validate.rules).string.min_len = 1];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to a container name. --)
  // Name of the Storage Container
  string container_name = 2 [(validate.rules).string.min_len = 1];
  // The AAD client secret credential used to acquire a token for the AAD application that has the required
  // permissions on this Blob Storage Container.
  AzureClientSecretCredential client_secret_credential = 3 [(validate.rules).message.required = true];
}

message AzureClientSecretCredential {
  // Tenant ID of the Azure AD Application.
  string tenant_id = 1 [(validate.rules).string.min_len = 1];
  // Client ID of the Azure AD Application.
  string client_id = 2 [(validate.rules).string.min_len = 1];
  // Client secret to use for authentication.
  string client_secret = 3 [(validate.rules).string.min_len = 1];
}


message DataType {
  oneof data_type {
    option (validate.required) = true;
    entities.v1.CsvConfig csv = 1;
  }
}

message CsvConfig {
  string charset = 1;
}

/*
A batch exporter.
 */
message BatchExporter {
  BatchExporterRef ref = 1 [(validate.rules).message.required = true];
  oneof stream_or_key_stream_ref {
    option (validate.required) = true;

    StreamRef stream_ref = 2;
    KeyStreamRef key_stream_ref = 3;
  }
  // granularity of seconds, nanos is unused
  google.protobuf.Duration interval = 4 [(google.api.field_behavior) = REQUIRED, (validate.rules).duration = {
    gte: {seconds: 30},
    lte: {seconds: 3600}
  }];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to the sink by name. --)
  // Deprecated in favor of data_connector_ref
  string sink_name = 5 [deprecated = true, (validate.rules).string = {len: 0, ignore_empty: true}];
  string path_prefix = 6 [(validate.rules).string = {
    // Mostly taken from GCS object naming: https://cloud.google.com/storage/docs/objects#naming
    ignore_empty: true,
    max_len: 900, // Reserve 124 characters for filenames
    // Should not end with a slash
    pattern: "^.+[^\\/]$",
    not_contains: ".well-known/acme-challenge",
    not_in: [".", ".."]
  }];
  bool include_existing_events = 7;
  DataConnectorRef data_connector_ref = 8 [(validate.rules).message.required = true];
}

message ExtendedBatchExporter {
  // The UUID identifier of the Batch Exporter, used in Kubernetes
  string uuid = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  // The Kafka Topic name that the Batch Exporter reads from
  string topic = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  strmprivacy.api.entities.v1.BatchExporter exporter = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message BatchExporterRef {
  string billing_id = 1 [deprecated = true, (validate.rules).string = {len: 0, ignore_empty: true}];
  string name = 2 [(validate.rules).string = {
    ignore_empty: true,
    pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100
  }];
  string project_id = 3 [(validate.rules).string.uuid = true];
}

/*
Currently only our internal shared export cluster.
 */
message KafkaCluster {
  KafkaClusterRef ref = 1 [(google.api.field_behavior) = REQUIRED];
  string bootstrap_servers = 2 [(google.api.field_behavior) = REQUIRED];
  AuthMechanism auth_mechanism = 3 [(google.api.field_behavior) = REQUIRED];
  string token_uri = 4;
}

/*
How to refer to a certain Kafka cluster.
 */
message KafkaClusterRef {
  // (-- streammachine for the default export cluster --)
  string billing_id = 1;
  /*
  constraints: generic name constraint
  */
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100}];
  string project_id = 3 [(validate.rules).string = {uuid: true, ignore_empty: true}];
}

message KafkaExporter {
  KafkaExporterRef ref = 1 [(validate.rules).message.required = true];
  StreamRef stream_ref = 2 [(validate.rules).message.required = true];
  KafkaExporterTarget target = 3;
  repeated KafkaUser users = 4;
}

message KafkaExporterRef {
  string billing_id = 1;
  /*
  default value  <cluster-name>-<stream-name>

  constraints: generic name constraint
  */
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100}];
  string project_id = 3 [(validate.rules).string = {uuid: true, ignore_empty: true}];
}

message KafkaExporterTarget {
  // what cluster to produce to
  KafkaClusterRef cluster_ref = 1 [(validate.rules).message.required = true];
  /*
  the topic this exporter produces to
  constraints: access checked on creation of kafka exporter
  */
  string topic = 2 [(validate.rules).string = {
    // Kafka topic validations: https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/internals/Topic.java
    max_len: 249,
    pattern: "^[a-zA-Z0-9._-]+$"
  }];
  // used to access the target Kafka Cluster in case of OAuth based authentication
  string client_id = 3 [(validate.rules).string = {uuid: true, ignore_empty: true}];
  // used to access the target Kafka Cluster in case of OAuth based authentication
  string client_secret = 4 [(validate.rules).string = {ignore_empty: true, pattern: "^[ -~]+$"}];
}

/*
User credentials to consume from topic produced by Kafka Exporter.

The kafka exporter is linked to a certain cluster, so this entity is bound to a certain
kafka cluster.
 */
message KafkaUser {
  KafkaUserRef ref = 1 [(validate.rules).message.required = true];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We refer to the kafka exporter by name. --)
  string kafka_exporter_name = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  string topic = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
  string client_id = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
  string client_secret = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
  KafkaClusterRef cluster_ref = 7 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message KafkaUserRef {
  string billing_id = 1 [deprecated = true];
  string name = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  string project_id = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message ConsentLevels {
  repeated int32 consent_levels = 1;
}

/*
for descriptive purposes only.
 */
message ConsentLevelMapping {
  ConsentLevelMappingRef ref = 1 [(validate.rules).message.required = true];
  /*
  some text like 'analytics'
  constraints: generic name constraint
  */
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100}];
}

message ConsentLevelMappingRef {
  string billing_id = 1 [deprecated = true, (validate.rules).string = {max_len: 0; ignore_empty: true}];
  // the typically small integer value that we use in the events.
  int32 level = 2 [(validate.rules).int32 = {gte: 0}];
  string project_id = 3 [(validate.rules).string = {uuid: true}];
}

message Policy {
  string id = 1 [(validate.rules).string.uuid = true];
  string name = 2 [(validate.rules).string = {
    pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$",
    min_len: 4,
    max_len: 100
  }];
  string description = 3 [(validate.rules).string = {max_len: 1000}];
  string legal_grounds = 4 [(validate.rules).string = {max_len: 1000}];
  int32 retention_days = 5 [(validate.rules).int32 = {gte: 1}];
  State state = 6;

  enum State {
    STATE_UNSPECIFIED = 0;
    STATE_DRAFT = 1;
    STATE_ACTIVE = 2;
    STATE_ARCHIVED = 3;
  }
}

message WindowedEventCount {
  google.protobuf.Timestamp start_time = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp end_time = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  int64 event_count = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message SchemaRef {
  /* constraints: generic name constraint */
  string handle = 1 [(google.api.field_behavior) = REQUIRED];
  /* constraints: generic name constraint */
  string name = 2 [(google.api.field_behavior) = REQUIRED];
  /* constraints: `\d+\.\d+\.\d+ */
  string version = 3 [(google.api.field_behavior) = REQUIRED];
  SchemaType schema_type = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message Schema {
  SchemaRef ref = 1 [(validate.rules).message.required = true];
  State state = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- 'is' is intentional here (see https://google.aip.dev/140#booleans) --)
  bool is_public = 3;
  /*
  constraints: is no longer required provided simple_schema is not empty.
   */
  string definition = 4;
  string fingerprint = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
  SchemaMetadata metadata = 6;
  SimpleSchemaDefinition simple_schema = 7;
  // The UUID of this schema
  string id = 8 [(google.api.field_behavior) = OUTPUT_ONLY];

  /*
  constraints: overall size < 100000 TBD
   */
  message SimpleSchemaDefinition {
    /* constraints: printable characters */
    string name = 1 [(validate.rules).string = {pattern: "^[^\\pC]+$",}];
    /*
    constraints:
    dot separated sequence of name constraints
    must be Avro compatible. When absent becomes <handle>.<name>.v<version>
     */
    string namespace = 2 [(validate.rules).string = {
      ignore_empty: true,
      pattern: "^([a-zA-Z_][a-zA-Z0-9_]*)(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$",
    }];
    string doc = 3 [(validate.rules).string.max_len = 5000];
    repeated SimpleSchemaNode nodes = 4;
    // avro compatible name set by creator OR derived from name (thus ignore_empty = true)
    string avro_name = 5 [(validate.rules).string = {
      ignore_empty: true,
      pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$",
    }];
  }

  enum State {
    STATE_UNSPECIFIED = 0;
    /*
    This schema is valid and complete, but has not been accepted yet, can still be modified and also deleted.
     */
    DRAFT = 1;
    /*
    This schema is valid and complete can be used for events and batch jobs. It cannot be modified or deleted.
     */
    ACTIVE = 2;
    /*
    This schema is valid and complete has been active, but no more events can be sent using this schema. In-flight events are still processed.
     */
    ARCHIVED = 3;
    /*
    This schema is in review. It can be used once it has been approved.
     */
    IN_REVIEW = 4;
    /*
    This schema is still under construction.
    */
    INCOMPLETE = 5;
  }
}

message SimpleSchemaNode {
  SimpleSchemaNodeType type = 1 [(validate.rules).enum = {not_in: 0}];
  /*
  constraints: same as SimpleSchemaDefinition
   */
  string name = 2 [(validate.rules).string = {pattern: "^[^\\pC]+$",}];
  // avro compatible name set by creator OR derived from name
  string avro_name = 7 [(validate.rules).string = {
    ignore_empty: true,
    pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$",
  }];
  bool repeated = 3;
  bool required = 4;
  repeated SimpleSchemaNode nodes = 5;
  /* constraints:
  size < 5000
   */
  string doc = 6 [(validate.rules).string.max_len = 5000];
}


message SchemaMetadata {
  /*
  The human readable title of this Schema. Used in the Portal. Defaults to the Schema name. This field can be modified.
  */
  string title = 1 [(validate.rules).string = {
    ignore_empty: true,
    pattern: "^[^\\pC]+$",
    min_len: 4,
    max_len: 100
  }];
  /*
  The description of this Schema. Used in the Portal. Markdown syntax is supported. This field can be modified.
  */
  string description = 2 [(validate.rules).string.max_len = 5000];
  // The timestamp when this Schema was created.
  google.protobuf.Timestamp create_time = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  // The URI to the icon used with this Schema. This always an absolute URI, with the https scheme. Used in the Portal.
  string icon_uri = 4 [(validate.rules).string = {prefix: "https://", uri: true, ignore_empty: true}];
  // Generic (key/value) labels for this Schema.
  repeated Label labels = 5;
  repeated string domains = 6;
  repeated string industries = 7;
}

message EventContractRef {
  /* constraint: handle should already exist */
  string handle = 1 [(validate.rules).string.min_len = 4];
  /* constraints: generic name constraint, unique within handle */
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100}];
  /* constraints: semantic version, e.g. 1.12.3 */
  string version = 3 [(validate.rules).string = {pattern: "^\\d+\\.\\d+\\.\\d+$"}];
}

message EventContract {
  EventContractRef ref = 1 [(google.api.field_behavior) = REQUIRED];
  State state = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  SchemaRef schema_ref = 3 [(google.api.field_behavior) = REQUIRED];
  // (-- 'is' is intentional here (see https://google.aip.dev/140#booleans) --)
  bool is_public = 4;
  // FIXME rename key_field to event_sequence_field
  string key_field = 5 [(google.api.field_behavior) = REQUIRED];
  map<string, int32> pii_fields = 6;
  repeated Validation validations = 7;
  EventContractMetadata metadata = 8;
  // The UUID of this event contract
  string id = 9;
  string data_subject_field = 10;

  enum State {
    STATE_UNSPECIFIED = 0;
    /*
    This event contract is valid and complete, but has not been accepted yet, can still be modified and also deleted.
     */
    DRAFT = 1;
    /*
    This event contract is valid and complete can be used for events and batch jobs. It cannot be modified or deleted.
     */
    ACTIVE = 2;
    /*
    This event contract is valid and complete has been active, but no more events can be sent using this schema. In-flight events are still processed.
     */
    ARCHIVED = 3;
    /*
    This event contract is in review. It can be used once it has been approved.
     */
    IN_REVIEW = 4;
    /*
    This event contract is still under construction.
    */
    INCOMPLETE = 5;
  }
}

message EventContractMetadata {
  // The human readable title of this Event Contract. Used in the Portal. Defaults to the Event Contract name. This field can be modified.
  string title = 1 [(google.api.field_behavior) = OPTIONAL];
  // The (optional) description of this Event Contract. Used in the Portal. Markdown syntax is supported. This field can be modified.
  string description = 2 [(google.api.field_behavior) = OPTIONAL];
  // The timestamp when this Event Contract was created.
  google.protobuf.Timestamp create_time = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  // The (optional) URI to the icon used with this Event Contract. This always an absolute URI, with the https scheme. Used in the Portal.
  string icon_uri = 4 [(google.api.field_behavior) = OPTIONAL];
  // Generic (key/value) labels for this Event Contract.
  repeated Label labels = 5 [(google.api.field_behavior) = OPTIONAL];
  repeated string domains = 6 [(google.api.field_behavior) = OPTIONAL];
  repeated string industries = 7 [(google.api.field_behavior) = OPTIONAL];
}

message Label {
  // The key of the label.
  string key = 1 [(validate.rules).string.min_len = 1];
  // The value of the label. An empty string means there is no value.
  string value = 2;
}

message Validation {
  /* constraint: valid field path, follows avro constraints + slashes */
  string field = 1 [(validate.rules).string.min_len = 1];
  /* constraint: one of the validator types. handled by code
  This should become an enum
  */
  string type = 2 [(validate.rules).string = {in: ["regex"]}];
  /* constraint: a type specific definition */
  string value = 3 [(validate.rules).string.min_len = 1];
}

message StreamTree {
  Stream stream = 1 [(google.api.field_behavior) = REQUIRED];
  KeyStream key_stream = 2;
  repeated Stream derived = 3;
  repeated BatchExporter batch_exporters = 4;
  repeated KafkaExporter kafka_exporters = 5;
}

message SinkTree {
  option deprecated = true;
  Sink sink = 1 [(google.api.field_behavior) = REQUIRED];
  repeated BatchExporter batch_exporters = 2;
}

/*********************************
 Batch Jobs
 Currently we only support:
 - CSV as DataFormat type
 - a clean database for every batch job
 - CSV files with a header row, because the header is needed to get the field names
*********************************/
message BatchJob {
  BatchJobRef ref = 1 [(validate.rules).message.required = true];
  repeated BatchJobState states = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  DataConnectorAndType source_data = 3 [(validate.rules).message.required = true];
  ConsentConfig consent = 4 [(validate.rules).message.required = true];
  EncryptionConfig encryption = 5 [(validate.rules).message.required = true];
  EventContractRef event_contract_ref = 6 [(validate.rules).message.required = true];
  EncryptedData encrypted_data = 7 [(validate.rules).message.required = true];
  EncryptionKeysData encryption_keys_data = 8 [(validate.rules).message.required = true];
  repeated DerivedData derived_data = 9;
  string policy_id = 10 [(validate.rules).string = {uuid: true, ignore_empty: true}];
}

message BatchJobWrapper {
  oneof job {
    option (validate.required) = true;

    entities.v1.BatchJob encryption_batch_job = 1;
    entities.v1.MicroAggregationBatchJob micro_aggregation_batch_job = 2;
  }
}

message ExtendedBatchJob {
  BatchJob batch_job = 1 [deprecated = true];
  BatchJobWrapper job = 2;
}

message BatchJobRef {
  string billing_id = 1 [deprecated = true, (validate.rules).string = {len: 0, ignore_empty: true}];
  // the UUIDv4 of the job, generated upon creation
  string id = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  // the UUIDv4 of the STRM Privacy project
  string project_id = 3 [(validate.rules).string.uuid = true];
}

message BatchJobState {
  google.protobuf.Timestamp state_time = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  BatchJobStateType state = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  string message = 3 [(google.api.field_behavior) = OPTIONAL];
}

message DataConnectorAndType {
  DataConnectorRef data_connector_ref = 1 [(validate.rules).message.required = true];
  // If omitted, files are read from the root of the bucket.
  string path_prefix = 2 [(validate.rules).string = {
    // Mostly taken from GCS object naming: https://cloud.google.com/storage/docs/objects#naming
    ignore_empty: true,
    max_len: 900, // Reserve 124 characters for filenames
    // Should not end with a slash
    pattern: "^.+[^\\/]$",
    not_contains: ".well-known/acme-challenge",
    not_in: [".", ".."]
  }];
  // (-- api-linter: core::0122::name-suffix=disabled
  //     aip.dev/not-precedent: We think file_name is a better name. --)
  string file_name = 3 [(validate.rules).string = {ignore_empty: true, pattern: "^[^\\pC]+$"}];
  DataType data_type = 4 [(validate.rules).message.required = true];
}

message ConsentConfig {
  repeated int32 default_consent_levels = 1 [(google.api.field_behavior) = OPTIONAL];
  ConsentLevelExtractor consent_level_extractor = 2 [(google.api.field_behavior) = OPTIONAL];
}

message ConsentLevelExtractor {
  string field = 1;
  map<string, ConsentLevels> field_patterns = 2;
}

message EncryptionConfig {
  TimestampConfig timestamp_config = 1 [(validate.rules).message.required = true];
  string batch_job_group_id = 2;
}

message TimestampConfig {
  // generic field name
  string field = 1 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 50}];
  // Java Time Format template, see https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html
  string format = 2 [(validate.rules).string = {min_len: 1}];
  google.type.TimeZone default_time_zone = 3;
}

message EncryptedData {
  DataConnectorAndType target = 1 [(validate.rules).message.required = true];
}

message EncryptionKeysData {
  DataConnectorAndType target = 1 [(validate.rules).message.required = true];
}

message DerivedData {
  DataConnectorAndType target = 1 [(google.api.field_behavior) = REQUIRED];
  repeated int32 consent_levels = 2;
  ConsentLevelType consent_level_type = 3;
  MaskedFields masked_fields = 4;
}

/*********************************
 K-Member Micro-aggregation Batch Job
 Currently we only support:
 - CSV as DataFormat type
 - CSV files with a header row, because the header is needed to get the field names
 - Numerical, Categorical & Ordinal data
*********************************/
message MicroAggregationBatchJob {
  BatchJobRef ref = 1 [(validate.rules).message.required = true];
  repeated BatchJobState states = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
  DataConnectorAndType source_data = 3 [(validate.rules).message.required = true];
  DataConnectorAndType target_data = 4 [(validate.rules).message.required = true];
  DataContractRef data_contract_ref = 5 [(validate.rules).message.required = true];
  // Configuration specifically for the aggregation algorithm.
  MicroAggregationConfig aggregation_config = 6 [(validate.rules).message.required = true];
}

message MicroAggregationConfig {

  // The desired k-anonymity level.
  int32 minimum_k_anonymity = 1 [(validate.rules).int32.gte = 2];
  // If specified, these fields will be used to aggregate on. Otherwise, fields specified as Quasi Identifiers in the data contract are used instead.
  repeated string aggregation_fields = 2;
}

message DataContractRef {
  /* constraint: handle should already exist */
  string handle = 1 [(google.api.field_behavior) = REQUIRED, (validate.rules).string.min_len = 4];
  /* constraints: generic name constraint, unique within handle */
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 4, max_len: 100}];
  /* constraints: semantic version, e.g. 1.12.3 */
  string version = 3 [(google.api.field_behavior) = REQUIRED, (validate.rules).string = {
    pattern: "^\\d+\\.\\d+\\.\\d+$"
  }];
}

message DataContract {
  string id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  DataContractRef ref = 2 [(validate.rules).message.required = true];
  State state = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  // (-- 'is' is intentional here (see https://google.aip.dev/140#booleans) --)
  bool is_public = 4;
  string key_field = 5 [(validate.rules).string.min_len = 1];
  // PII Fields as a map, where the key is the field path (i.e. producerSessionId or customer/id) and the
  // value is the purpose level, provided as an integer
  map<string, int32> pii_fields = 6 [deprecated = true];
  repeated Validation validations = 7;
  DataContractMetadata metadata = 8;
  Schema schema = 9 [(validate.rules).message.required = true];
  string data_subject_field = 10;
  string project_id = 11 [(validate.rules).string.uuid = true];
  repeated FieldMetadata field_metadata = 12;

  enum State {
    STATE_UNSPECIFIED = 0;
    /*
    This data contract is valid and complete, but has not been accepted yet, can still be modified and also deleted.
     */
    DRAFT = 1;
    /*
    This data contract is in review. It can be used once it has been approved.
     */
    IN_REVIEW = 2;
    /*
    This data contract is valid and complete can be used for events and batch jobs. It cannot be modified or deleted.
     */
    ACTIVE = 3;
    /*
    This data contract is valid and complete has been active, but no more events can be sent using this data contract. In-flight events are still processed.
     */
    ARCHIVED = 4;
    /*
    This data contract is still under construction.
    */
    INCOMPLETE = 5;
  }
}

message FieldMetadata {
  // Full reference to a (nested) field. For non-top-level fields (i.e. nested fields), each level should be separated by a forward slash. E.g. customer/id.
  string field_name = 1;
  // Metadata on the type of personal data this field may contain.
  PersonalDataConfig personal_data_config = 2;
  // The statistical data type of the field, e.g. nominal, ordinal, numerical.
  StatisticalDataType statistical_data_type = 3;
  // If a field is of ordinal values, defines the possible values and their order.
  repeated string ordinal_values = 4;
  // How null values should generally be dealt with for a field.
  NullHandlingConfig null_handling_config = 5;

  message PersonalDataConfig {
    // Currently, only string fields or repeated string fields can be marked as PII, since other data types cannot store an encrypted string.
    bool is_pii = 1 [(google.api.field_behavior) = REQUIRED];
    // A quasi identifier doesn't identify an individual directly, but combined with other QIs can result in a unique (direct) identifier.
    bool is_quasi_id = 2 [(google.api.field_behavior) = REQUIRED];
    // The purpose level as defined in the purpose level mapping of an organization.
    int32 purpose_level = 3;
    // The special sensitive data type as defined by the GDPR https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32016R0679#d1e2051-1-1
    string gdpr_special_personal_data_type = 4;
  }

  message NullHandlingConfig {
    NullHandlingType type = 1 [(google.api.field_behavior) = REQUIRED];
    // If the type is DEFAULT_VALUE, the desired default value must be specified.
    string default_value = 2;

    enum NullHandlingType {
      NULL_HANDLING_TYPE_UNSPECIFIED = 0;
      DROP_RECORD = 1;
      DEFAULT_VALUE = 2;
    }
  }
}

message DataContractMetadata {
  // The human readable title of this Data Contract. Used in the Portal. Defaults to the Data Contract name if left unspecified. This field can be modified.
  string title = 1 [(validate.rules).string = {
    ignore_empty: true,
    pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$",
    min_len: 4,
    max_len: 100
  }];
  // The description of this Data Contract. Used in the Portal. Markdown syntax is supported. This field can be modified.
  string description = 2;
  // The timestamp when this Data Contract was created.
  google.protobuf.Timestamp create_time = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
  // Generic (key/value) labels for this Data Contract.
  repeated Label labels = 5;
  repeated string domains = 6;
  repeated string industries = 7;
}

message Project {
  string id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
  string name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 2, max_len: 100}];
  string description = 3 [(validate.rules).string = {max_len: 5000}];
  string organization_id = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
  State state = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
  enum State {
    STATE_UNSPECIFIED = 0;
    OPERATIONAL = 1;
    PENDING_DELETION = 2;
  }
}

// (-- api-linter: core::0148::human-names=disabled
//     aip.dev/not-precedent . --)
message User {
  string email = 1 [(validate.rules).string = {email: true, ignore_empty: true}];
  string first_name = 2 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 2, max_len: 100}];
  string last_name = 3 [(validate.rules).string = {pattern: "^[\\pL\\pN\\pS\\pM\\pP]+$", min_len: 2, max_len: 100}];
  repeated UserRole user_roles = 4;
}

message PurposeMapping {
  // an integer, which retains the same technical function as the original "consent level"
  int32 level = 1 [(validate.rules).int32.gte = 0];
  // a name/short description of the purpose, e.g. "Analytics", "Functional"
  string purpose = 2 [(validate.rules).string = {min_len: 2, max_len: 100}];
  // a more elaborate description
  string description = 3 [(validate.rules).string = {ignore_empty: true, min_len: 2}];
}

enum UserRole {
  USER_ROLE_UNSPECIFIED = 0;
  ADMIN = 1;
  PROJECT_ADMIN = 2;
  APPROVER = 3;
  MEMBER = 4;
}

enum BatchJobStateType {
  BATCH_JOB_STATE_TYPE_UNSPECIFIED = 0;
  PENDING = 1;
  STARTED = 2;
  ERROR_STARTING = 3;
  RUNNING = 4;
  FINISHED = 5;
  ERROR = 6;
}

/*
Consent level is meant to interpret the consent-levels of an event for decryption purposes only.

Cumulative means that the highest consent-level in an event must be greater than or equal to the single requested level
for the decrypted stream.

Granular means that the set of consent-levels in an event must enclose the set of requested event levels for the
decrypted stream.
 */
enum ConsentLevelType {
  CONSENT_LEVEL_TYPE_UNSPECIFIED = 0;
  CUMULATIVE = 1;
  GRANULAR = 2;
}

enum SinkType {
  option deprecated = true;
  SINK_TYPE_UNSPECIFIED = 0;
  S3 = 1;
  GCLOUD = 2;
}

// (-- TODO align values with JAAS. see https://docs.confluent.io/platform/current/kafka/overview-authentication-methods.html --)
//     also see the Kafka exporter to determine the correct terminology here
//     SASL_SSL should probably be SASL_OAUTHBEARER --)
enum AuthMechanism {
  AUTH_MECHANISM_UNSPECIFIED = 0;
  SASL_PLAIN = 1;
  SASL_SSL = 2;
}

enum SchemaType {
  SCHEMA_TYPE_UNSPECIFIED = 0;
  AVRO = 1;
  JSONSCHEMA = 2;
}

enum SimpleSchemaNodeType {
  SIMPLE_SCHEMA_NODE_TYPE_UNSPECIFIED = 0;
  STRING = 1;
  BOOLEAN = 2;
  FLOAT = 3;
  INTEGER = 4;
  LONG = 5;
  NODE = 10;
}

enum FilterPublicPrivate {
  FILTER_PUBLIC_PRIVATE_UNSPECIFIED = 0;
  ONLY_PUBLIC = 1;
  ONLY_PRIVATE = 2;
}

enum StatisticalDataType {
  STATISTICAL_DATA_TYPE_UNSPECIFIED = 0;
  NOMINAL = 1;
  ORDINAL = 2;
  NUMERICAL = 3;
}

enum SubscriptionPlan {
  SUBSCRIPTION_PLAN_UNSPECIFIED = 0;
  FREE = 1;
  BUSINESS = 2;
  SELF_HOSTED = 3;
  AWS_MARKETPLACE_PAYG = 4;
  AWS_MARKETPLACE_BYOL = 5;
}
